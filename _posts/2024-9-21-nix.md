---
layout: post
title: The Simple Nix Guide
tags: nix
---


### Why

use `nix develop` to spawn a shell with an application's development dependenciesin scope. To achieve this, you should create a flake that uses `mkShell`.



### What

**Nix Ecosystem**

- nix package manager
  - non-FHS compliant
  - declarative configuration (versus imperative approach)
- nix language
  - like JSON with functions
- NixOS
- nixpgks
  - more than 10000 packages
  - builder functions
    - mkShell
  - utility functions

### How

- To check `nix store` disk usage: `du -hsc /nix/store`.
- To reduce nix store disk uage: `nix-collect-garbage`.
- For the design of nix, same servide will be launched for differernt project. To avoid conflicts, we can assign differernt ports for them. And kill those service on leave `nix shell`.


A samll discovery of rails. Rails will use `PGPORT` env variable, if it's defined, and use that port to connect to psql.

- Here is how to quit on exit shell: https://github.com/legendofmiracles/lila/blob/nix/shell.nix

but above only works on bash. for zsh, I have no clue.



### Flake

A nix package manager feature that encforces a uniform structure for nix projects, pinning versions of dependencies in lock file.

- `nix flake init`: initialize a basic flake.nix file.

**Structure**

- description: a string
- inputs: an attrset
- outpus: a function

```
{
  description = "A very basic flake";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs?ref=nixos-unstable";
  };

  outputs = { self, nixpkgs } : {
    packages.aarch64.default = nixpkgs.legacyPackages.aarch64.hello;
```

**Commands**

- `nix run`: run a packaged binary.
  - outputs.packages."SYSTEM".default
- `nix build`: build a package.
  - outpus.packages."SYSTEM".default
- `nix develop`: activiates a dev shell.
  - outpus.devShells."SYSTEM".default
- `nixos-rebuild`: build a nixos system.
  - outpus.nixosConfigurations."HOSTNAME"
- `home-manager`: build a home configuration.
  - outputs.homeConfigurations."USERNAME"

a flake's outputs attrbiue is a function that takes the flake's inputs as an argument.

The first time an input is used in a flake command, Nix will pin it. Pinning an input means that Nix will fiture out the exact revision that it fetched, making sure everybody using this flake gets the exact the same one.

let bindings:

let
  system = builtins.currentSystem;
  pkgs = import nixpkgs { inherit sytem; };
in
{
  dev

- lookup paths: enclosing a path in angle brackets, e.g. <nixkpgs> causes the directories listent in the env variable `NIX_PATH` to be searched for the given file or directory name.

- Attrbute sets: key-value association.

- `android-sdks.inputs.nixpkgs.follows = "nixpkgs": this means the input (android-sdks) will have the same `nixpkgs` as input as current nixpkgs. 




**References**:

- [Nix Language Basics](https://nix.dev/tutorials/nix-language)
- ['nix shell' vs 'nix develop'](https://www.reddit.com/r/NixOS/comments/r15hx4/nix_shell_vs_nix_develop/)
