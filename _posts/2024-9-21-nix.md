---
layout: post
title: The Simple Nix Guide
tags: nix
---


### Why

use `nix develop` to spawn a shell with an application's development dependenciesin scope. To achieve this, you should create a flake that uses `mkShell`.



### What

**Nix Ecosystem**

- nix package manager
  - non-FHS compliant
  - declarative configuration (versus imperative approach)
- nix language
  - like JSON with functions
- NixOS
- nixpgks
  - more than 10000 packages
  - builder functions
    - mkShell
  - utility functions

### How

- To check `nix store` disk usage: `du -hsc /nix/store`.
- To reduce nix store disk uage: `nix-collect-garbage`.
- For the design of nix, same servide will be launched for differernt project. To avoid conflicts, we can assign differernt ports for them. And kill those service on leave `nix shell`.


A samll discovery of rails. Rails will use `PGPORT` env variable, if it's defined, and use that port to connect to psql.

- Here is how to quit on exit shell: https://github.com/legendofmiracles/lila/blob/nix/shell.nix

but above only works on bash. for zsh, I have no clue.



### Flake

A nix package manager feature that encforces a uniform structure for nix projects, pinning versions of dependencies in lock file.

- `nix flake init`: create a flake in the current directory from a template.
- `nix flake show`: show outputs of a flake.
- `nix flake metadata`: show flake metadata.

**Structure**

- description: a string
- inputs: an attrset
- outputs: a function that takes `self` (current flake) and `inputs` as arguments.

```
{
  description = "A very basic flake";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs?ref=nixos-unstable";
    home-manager.url = "github:nix-community/home-manager";
    home-manager.inputs.nixpkgs.follows = "nixkpgs"; /* home-manager will use nixkpgs from above, instead of its own version of nixpkgs. */
  };

  outputs = { self, nixpkgs } : /* self refers to current flake; nixpkgs is a flake from inputs */
  let
    pkgs = nixpkgs.legacyPackages.aarch64.hello;
  in
  {
    /* For nix run */
    packages.aarch64.default = nixpkgs.legacyPackages.aarch64.hello; /* hello is one of ouputs of nixkpgs flake. */
    
    /* For nix develop */
    devShells.aarch64.default = pkgs.mkShell { /* mkShell is a function from nixpkgs outputs. */
      buildInputs = [pkgs.vim];
    }

    /* For NixOS */
    nixosConfigurations.nixos = nixpkgs.lib.nixosSystem {
      modules = [
        ./configuration.nix
        ({ pkgs, ... } : {
          programs.vim.defaultEditor = true;
        })
      ];
    };
  };
```


**Commands**

- `nix run`: builds and runs an installable, which must evaluate to an app or regular nix derivation.
  - outputs.packages."SYSTEM".default
- `nix build`: build a package.
  - outpus.packages."SYSTEM".default
- `nix develop`: run a bash shell that provides the build environment of a derivation.
  - outpus.devShells."SYSTEM".default
- `nixos-rebuild`: build a nixos system.
  - outpus.nixosConfigurations."HOSTNAME"
- `home-manager`: build a home configuration.
  - outputs.homeConfigurations."USERNAME"

**Flake References**

- attribute set representation:
```
{
  type = "github";
  owner = "NixOS";
  repo = "nixpkgs";
}
```

- url-like syntax
```
// same as above attribute set
github:NixOS/nixpkgs
```

a flake's outputs attrbiue is a function that takes the flake's inputs as an argument.

The first time an input is used in a flake command, Nix will pin it. Pinning an input means that Nix will fiture out the exact revision that it fetched, making sure everybody using this flake gets the exact the same one.



**References**:

- [Nix Language Basics](https://nix.dev/tutorials/nix-language)
- [Nix Reference Manual](https://nix.dev/manual/nix/2.18)
- [Ultimate Nix Guide](https://www.youtube.com/watch?v=JCeYq72Sko0&t=905s)
- ['nix shell' vs 'nix develop'](https://www.reddit.com/r/NixOS/comments/r15hx4/nix_shell_vs_nix_develop/)
